#!/usr/bin/env python
#
import sys
import copy

_ESC = chr(0x1B)
_SPC = chr(32)

# ATTRIBS
_RESET      = 0
_BRIGHT     = 1
_DIM        = 2
_UNDERSCORE = 3
_BLINK      = 5
_REVERSE    = 7
_HIDDEN     = 8

# COLORS
_FG = 30
_BG = 40

_BLACK   = 0
_RED     = 1
_GREEN   = 2
_YELLOW  = 3
_BLUE    = 4
_MAGENTA = 5
_CYAN    = 6
_WHITE   = 7

# Simple text surface
class TxtSurface:
    def __init__(self, size, data = []):
        self.dirty = False
        self.size = size
        if not (len(data) == (self.size[0] * self.size[1])):
            self.srf = [ord(_SPC)] * (self.size[0] * self.size[1])
        else:
            self.srf = data

    def clear(self):
        self.srf = [32] * (self.size[0] * self.size[1])
        self.dirty = True

    def resize(self, new_size):
        if new_size == self.size:
            return

        # Get crop rectangle
        min_x = min(self.size[0], new_size[0])
        min_y = min(self.size[1], new_size[1])

        new_srf = [ord(_SPC)] * (new_size[0] * new_size[1])
        # Copy lines
        new_ind = 0
        for y in range(min_y):
            # Copy source line
            new_srf[new_ind : new_ind + min_x] = self.srf[0:min_x]
            new_ind += new_size[0]
        self.srf = new_srf
        self.size = new_size
        self.dirty = True
        
    def blit(self, position, surface):
        if (surface.size > self.size):
            # Raises an exception!!
            return
        (px, py) = position
        # Calc crop area
        line_len = (px + surface.size[0]) % self.size[0]
        lines = (px + surface.size[1]) % self.size[1]
        # Initial copy index
        srf_ind = (py * self.size[0]) + px
        # Dump lines
        for y in range(lines):
            self.srf[srf_ind:srf_ind + line_len] = surface.srf[:line_len]
            srf_ind += self.size[0]
        self.dirty = True

    # Need to crop text lines?
    def dump_text(self, position, text,
             attributes = _RESET, color = _WHITE, background = _BLACK):
        ind = (self.size[0] * (position[1] % self.size[1]) +
               (position[0] % self.size[0]))
        for itext in range(len(text)):
            attribute = attributes | (color << 3) | (background << 6)
            self.srf[ind + itext] = (attribute << 8) | ord(text[itext])
        self.dirty = True     

    def force_background(self, background):
        for i in range(len(self.srf)):
            char = self.srf[i]
            attr = (char >> 8)
            char &= 0xFF
            # Set new background
            attr &= 0b000111111
            attr |= (background & 7) << 6
            self.srf[i] = char | (attr << 8)
# Console
class Console(TxtSurface):
    def __init__(self):
        # This is bogus!
        TxtSurface.__init__(self, self.__getConsoleSize())
        self.reset()

    def reset(self):
        self.__cls()
        self.size = self.__getConsoleSize()
        self.srf = [ord(_SPC)] * (self.size[0] * self.size[1])
        self.attr = 0
        self.color = _BLACK
        self.background = _WHITE        
        self.position = (0, 0)
        self.__setCursorPos(self.position)
        self.clear()
        self.dirty = False

    def put_str(self, string):
        self.dump_text(self.position, string,
                       self.attr, self.color, self.background)
        self.position = ((self.position[0] + len(string)) % self.size[0],
                         (self.position[1] + int(len(string) / self.size[0])) & self.size[1])

    def put_line(self, string):
        self.put_str(string)
        self.position = (0, (self.position[1] + 1) % self.size[1])

    def maximize(self):
        size = self.__getConsoleSize()
        if (size != self.size):
            self.resize(size)

    def frame(self):
        if not self.dirty:
            return
        attribute = -1
        self.__setCursorPos((0, 0))
        for ind in range(len(self.srf)):
            char = self.srf[ind]
            new_attribute = (char >> 8)
            if (new_attribute != attribute):
                attribute = new_attribute
                self.__set_attributes(attribute)
            sys.stdout.write(chr(char & 0xFF))
        sys.stdout.flush()
        self.dirty = False

    def __getConsoleSize(self):
        def ioctl_GWINSZ(fd):
            try:
                import fcntl, termios, struct, os
                cr = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'))
            except:
                return None
            return cr
        cr = ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2)
        if not cr:
            try:
                fd = os.open(os.ctermid(), os.O_RDONLY)
                cr = ioctl_GWINSZ(fd)
                os.close(fd)
            except:
                pass
        if not cr:
            try:
                cr = (env['LINES'], env['COLUMNS'])
            except:
                cr = (25, 80)
        return int(cr[1]), int(cr[0])

    def __set_attributes(self, attrs):
        sys.stdout.write(_ESC + '[' + str(attrs & 0x07) + ';' +
                         str(((attrs >> 3) & 0x07) + _FG) + ';' +
                         str(((attrs >> 6) & 0x07) + _BG) + 'm')
        sys.stdout.flush()
      
    def __setCursorPos(self, pos):
        sys.stdout.write(_ESC + '[' + str(pos[1] % self.size[1]) + ';' + str(pos[0] & self.size[0]) + 'f')
        sys.stdout.flush()

    def __cls(self):
        sys.stdout.write(_ESC + '[2J')
        sys.stdout.flush()

    def end(self, with_clear = False):
        self.__set_attributes(449)
        if with_clear:
            self.__cls()

if __name__ == '__main__':
    console = Console()
    console.force_background(_RED)
    console.frame()
    console.end()
